package me.friendly.exeter.module.impl.exploits;

import me.friendly.api.event.Listener;
import me.friendly.api.minecraft.helper.MovementHelper;
import me.friendly.exeter.events.MoveEvent;
import me.friendly.exeter.events.PacketEvent;
import me.friendly.exeter.logging.Logger;
import me.friendly.exeter.module.ModuleType;
import me.friendly.exeter.module.ToggleableModule;
import me.friendly.exeter.properties.EnumProperty;
import me.friendly.exeter.properties.NumberProperty;
import me.friendly.exeter.properties.Property;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;
import org.apache.commons.logging.Log;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class PacketFly extends ToggleableModule {
    private static final double CONCEAL = 0.0624;
    private static final double MOVE_FACTOR = 1.0 / Math.sqrt(2.0);

    private final EnumProperty<Mode> mode = new EnumProperty<>(Mode.FACTOR, "Mode", "m");
    private final NumberProperty<Float> factor = new NumberProperty<>(1.5f, 0.1f, 5.0f, "Factor", "f", "loops");
    private final EnumProperty<Bounds> bounds = new EnumProperty<>(Bounds.DOWN, "Bounds", "vanillafucker");
    private final EnumProperty<Phase> phase = new EnumProperty<>(Phase.FULL, "Phase", "phasing", "p");
    private final Property<Boolean> conceal = new Property<>(false, "Conceal", "slow");
    private final Property<Boolean> zero = new Property<>(false, "Zero", "0");
    private final Property<Boolean> antiKick = new Property<>(true, "Anti-Kick", "antikick", "antik", "noflykick");

    private final Map<Integer, Vec3d> predictions = new ConcurrentHashMap<>();
    private final List<CPacketPlayer> movePackets = new CopyOnWriteArrayList<>();
    private int teleportID = 0;
    private int lag = 0;

    public PacketFly() {
        super("Packet Fly", new String[]{"packetfly", "pkfly", "pfly"}, ModuleType.EXPLOITS);
        offerProperties(mode, factor, bounds, phase, conceal, zero, antiKick);

        listeners.add(new Listener<PacketEvent>("packetfly_packet_listener") {
            @Override
            public void call(PacketEvent event) {
                if (!mc.player.connection.doneLoadingTerrain) {
                    return;
                }

                if (event.getPacket() instanceof SPacketPlayerPosLook) {
                    SPacketPlayerPosLook packet = event.getPacket();

                    packet.yaw = mc.player.rotationYaw;
                    packet.pitch = mc.player.rotationPitch;

                    teleportID = packet.teleportId;

                    Vec3d prediction = predictions.get(packet.teleportId);
                    if (prediction != null) {

                        if (prediction.xCoord == packet.x && prediction.yCoord == packet.y && prediction.zCoord == packet.z) {
                            predictions.remove(packet.teleportId);
                            mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.teleportId));

                            if (mode.getValue().equals(Mode.FACTOR)) {
                                event.setCanceled(true);
                            }

                            // Logger.getLogger().printToChat("Predicted " + teleportID);

                            return;
                        }
                    }

                    lag = 10;
                    mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.teleportId));
                    // Logger.getLogger().printToChat("No prediction/invalid prediction " + teleportID);
                } else if (event.getPacket() instanceof CPacketPlayer) {
                    if (!movePackets.remove((CPacketPlayer) event.getPacket())) {
                        event.setCanceled(true);
                    }
                }
            }
        });

        listeners.add(new Listener<MoveEvent>("packetfly_move_listener") {
            @Override
            public void call(MoveEvent event) {

                double moveSpeed = conceal.getValue() ? CONCEAL : 0.2873;

                double motionY = 0.0;
                if (antiKick.getValue()) {

                    // -0.04 should be enough because mc only checks for -0.03125
                    if (mc.player.ticksExisted % 40 == 0 && !isPhased() && !mc.world.collidesWithAnyBlock(mc.player.getEntityBoundingBox())) {
                        motionY = -0.04;
                    }
                }

                int loops = (int) Math.floor(factor.getValue());
                if (mode.getValue().equals(Mode.FACTOR)) {

                    if (lag > 0) {
                        --lag;
                        moveSpeed = CONCEAL;
                        loops = 1;
                    } else {
                        if (!isPhased() && mc.player.ticksExisted % 10.0 < 10.0 - (loops - Math.floor(loops))) {
                            loops++;
                        }
                    }
                }

                double f = isPhased() && phase.getValue().equals(Phase.FULL) ? 0.03 : CONCEAL;
                if (isPhased() && phase.getValue().equals(Phase.FULL)) {
                    moveSpeed = CONCEAL;
                }

                if (mc.gameSettings.keyBindJump.isKeyDown()) {
                    motionY = f;
                    moveSpeed *= MOVE_FACTOR;
                } else if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                    motionY = -f;
                    moveSpeed *= MOVE_FACTOR;
                }

                sendPackets(loops, moveSpeed, motionY);

                event.x = mc.player.motionX;
                event.y = motionY;
                event.z = mc.player.motionZ;

                if (!phase.getValue().equals(Phase.NONE)) {
                    mc.player.noClip = true;
                }
            }
        });
    }

    @Override
    protected void onDisable() {
        super.onDisable();

        mc.player.noClip = false;

        predictions.clear();
        movePackets.clear();
        teleportID = 0;
        lag = 0;
    }

    private void sendPackets(int f, double moveSpeed, double motionY) {
        double[] motion = MovementHelper.calcMotion(moveSpeed);
        if (!MovementHelper.isMoving()) {
            motion = new double[] {0.0, 0.0};
        }

        for (int i = 1; i < f + 1; ++i) {
            double motionX = motion[0] * i;
            double motionV = motionY * i;
            double motionZ = motion[1] * i;

            Vec3d vec = mc.player.getPositionVector().addVector(motionX, motionV, motionZ);
            sendPacket(vec);

            mc.player.setVelocity(motionX, motionV, motionZ);

            if (!mc.isSingleplayer()) {
                Vec3d v = vec.addVector(0.0, bounds.getValue().offset, 0.0);
                if (v.yCoord < 0.0 && zero.getValue()) {
                    v = new Vec3d(vec.xCoord, 0.0, vec.zCoord);
                }

                sendPacket(v);
            }

            teleportID++;
            predictions.put(teleportID, vec);

            mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportID));
        }
    }

    private void sendPacket(Vec3d vec) {
        Position position = new Position(vec.xCoord, vec.yCoord, vec.zCoord, true);
        mc.player.connection.sendPacketSilent(position);
        movePackets.add(position);
    }

    private boolean isPhased() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    public enum Mode {
        FACTOR, SETBACK
    }

    public enum Bounds {
        UP(1337.69420),
        DOWN(-1337.69420);

        private final double offset;

        Bounds(double offset) {
            this.offset = offset;
        }
    }

    public enum Phase {
        NONE, SEMI, FULL
    }
}
