package me.friendly.exeter.module.impl.exploits;

import me.friendly.api.event.Listener;
import me.friendly.api.minecraft.helper.MovementHelper;
import me.friendly.api.properties.EnumProperty;
import me.friendly.api.properties.NumberProperty;
import me.friendly.api.properties.Property;
import me.friendly.exeter.events.MoveEvent;
import me.friendly.exeter.events.PacketEvent;
import me.friendly.exeter.module.ModuleType;
import me.friendly.exeter.module.ToggleableModule;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.client.CPacketPlayer.Position;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.Vec3d;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class PacketFly extends ToggleableModule {
    private static final double CONCEAL = 0.0624;
    private static final double MOVE_FACTOR = 1.0 / Math.sqrt(2.0);

    private final EnumProperty<Mode> mode = new EnumProperty<>(Mode.FACTOR, "Mode", "m");
    private final NumberProperty<Float> factor = new NumberProperty<>(1.5f, 0.1f, 5.0f, "Factor", "f", "loops");
    private final EnumProperty<Bounds> bounds = new EnumProperty<>(Bounds.DOWN, "Bounds", "vanillafucker");
    private final EnumProperty<Phase> phase = new EnumProperty<>(Phase.FULL, "Phase", "phasing", "p");
    private final Property<Boolean> conceal = new Property<>(false, "Conceal", "slow");
    private final Property<Boolean> antiKick = new Property<>(true, "Anti-Kick", "antikick", "antik", "noflykick");

    private final Map<Integer, Vec3d> predictions = new ConcurrentHashMap<>();
    //private final List<CPacketPlayer> movePackets = new CopyOnWriteArrayList<>();
    private int teleportID = 0;
    private int lag = 0;

    public PacketFly() {
        super("Packet Fly", new String[]{"packetfly", "pkfly", "pfly"}, ModuleType.EXPLOITS);
        offerProperties(mode, factor, bounds, phase, conceal, antiKick);

        listeners.add(new Listener<PacketEvent>("packetfly_packet_listener") {
            @Override
            public void call(PacketEvent event) {
                if (!mc.player.connection.doneLoadingTerrain) {
                    return;
                }

                if (event.getPacket() instanceof SPacketPlayerPosLook) {
                    SPacketPlayerPosLook packet = event.getPacket();

                    Vec3d prediction = predictions.get(packet.teleportId);
                    if (prediction != null) {

                        predictions.remove(packet.teleportId);

                        if (prediction.xCoord == packet.x && prediction.yCoord == packet.y && prediction.zCoord == packet.z) {
                            if (mode.getValue().equals(Mode.FACTOR)) {
                                event.setCanceled(true);
                            }

                            mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.teleportId));

                            return;
                        }
                    }

                    packet.yaw = mc.player.rotationYaw;
                    packet.pitch = mc.player.rotationPitch;

                    mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.teleportId));

                    teleportID = packet.teleportId;
                    lag = 15;
                } else if (event.getPacket() instanceof CPacketPlayer) {
                    // i only always do this because we sent them silently
                    event.setCanceled(true);
                }
            }
        });

        listeners.add(new Listener<MoveEvent>("packetfly_move_listener") {
            @Override
            public void call(MoveEvent event) {

                int loops = (int) Math.floor(factor.getValue());
                if (mode.getValue().equals(Mode.FACTOR)) {

                    // todo: option if we should not factor while phasing?
                    if (mc.player.ticksExisted % 10 < 10 * (factor.getValue() - Math.floor(factor.getValue()))) {
                        loops++;
                    }
                } else {
                    loops = 1;
                }

                double moveSpeed = (conceal.getValue() || --lag > 0 || isPhased()) ? CONCEAL : 0.2873;
                double motionY = 0.0;

                boolean i = false;

                if (mc.gameSettings.keyBindJump.isKeyDown()) {
                    motionY = CONCEAL;

                    if (MovementHelper.isMoving()) {
                        motionY *= MOVE_FACTOR;
                        moveSpeed *= MOVE_FACTOR;
                    }
                } else if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                    motionY = -CONCEAL;

                    if (MovementHelper.isMoving()) {
                        motionY *= MOVE_FACTOR;
                        moveSpeed *= MOVE_FACTOR;
                    }
                } else {
                    i = antiKick.getValue()
                            && mc.player.ticksExisted % 40 == 0
                            && !isPhased()
                            && !mc.world.collidesWithAnyBlock(mc.player.getEntityBoundingBox())
                            && !MovementHelper.isMoving();

                    if (i) {
                        motionY = -0.04;
                        loops = 1;
                    }
                }

                sendPackets(loops, moveSpeed, motionY, i);

                event.x = mc.player.motionX;
                event.y = mc.player.motionY;
                event.z = mc.player.motionZ;

                if (!phase.getValue().equals(Phase.NONE)) {
                    mc.player.noClip = true;
                }
            }
        });
    }

    @Override
    protected void onDisable() {
        super.onDisable();

        if (mc.player != null) {
            mc.player.setVelocity(0.0, 0.0, 0.0);

            mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportID));
            mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(
                    mc.player.posX,
                    mc.player.getEntityBoundingBox().minY,
                    mc.player.posZ,
                    mc.player.rotationYaw,
                    mc.player.rotationPitch,
                    false));

            mc.player.noClip = false;
        }

        predictions.clear();
        // movePackets.clear();
        teleportID = 0;
        lag = 0;
    }

    private void sendPackets(int f, double moveSpeed, double motionY, boolean ignoreYFactor) {
        if (f == 0) {
            // null out our client-sided velocity if we have a 0 factor
            mc.player.setVelocity(0.0, 0.0, 0.0);
            return;
        }

        double[] motion = MovementHelper.calcMotion(moveSpeed);
        if (!MovementHelper.isMoving()) {
            motion = new double[] { 0.0, 0.0 };
        }

        for (int i = 1; i < f + 1; ++i) {
            double motionX = motion[0] * i;
            double motionZ = motion[1] * i;

            double motionV;
            if (ignoreYFactor) {
                motionV = -0.04;
            } else {
                motionV = motionY * i;
            }

            // set client-sided velocity
            mc.player.motionX = motionX;
            mc.player.motionY = motionV;
            mc.player.motionZ = motionZ;

            // our player position vector
            Vec3d vec = mc.player.getPositionVector();

            // our movement vector
            Vec3d moveVec = vec.addVector(motionX, motionV, motionZ);

            // send move packet
            sendPacket(moveVec);

            // send our "bounds" packet because we go out of bounds (100+ blocks) so we can teleport wherever (thanks mojang)
            sendPacket(vec.addVector(0.0, bounds.getValue().offset, 0.0));

            // add our prediction to our absolute move vector
            predictions.put(++teleportID, moveVec);
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportID));
        }
    }

    private void sendPacket(Vec3d vec) {
        Position position = new Position(vec.xCoord, vec.yCoord, vec.zCoord, true);
        mc.player.connection.sendPacketSilent(position);
        // movePackets.add(position);
    }

    private boolean isPhased() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    public enum Mode {
        FACTOR, SETBACK
    }

    public enum Bounds {
        UP(1337.69420),
        DOWN(-1337.69420);

        private final double offset;

        Bounds(double offset) {
            this.offset = offset;
        }
    }

    public enum Phase {
        NONE, SEMI, FULL
    }
}
